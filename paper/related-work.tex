\section{Related Work}

There are several bodies of work that explore improving data transfers between applications across a network.  IFTD sets itself apart from these prior works by not only allowing an application to transfer arbitrary data, but also completely removing the need for an application to be aware of any data transfer implementations while simultaneously providing a data transfer architecture that supports the concurrent use of arbitrarily complex data transfer protocols.

The differentiation between content negotiation and data transfer within IFTD is borrowed from the Data-Oriented Transfer (DOT) architecture~\cite{dot_paper}.  While DOT provides applications with the ability to transfer data without needing to implement their own data transfer protocols, it still requires that applications perform content negotiation directly.  IFTD performs both tasks on behalf of its client applications.

IFTD's protocol architecture is inspired by three different existing architectures: the transfer plugin architecture in DOT, the protocol plugin architecture in the peer-to-peer file-sharing service giFT~\cite{giFT}, and the package transport architecture arizonatransfer from the Stork package manager~\cite{stork_paper}.  All three provide data transfer protocol architectures that hide the details of the protocol implementation from the applications using them.  Also, they both provide a degree of protocol fault-tolerance during transmission by transparently switching from a failed protocol to an operational protocol.  Unlike giFT, however, the capabilities of IFTD's protocols are not constrained by a specific use-case, and unlike DOT, IFTD's protocol implementations may be internally non-resumable.  Additionally, IFTD can receive data concurrently using different protocols, which is beyond the capabilities of arizonatransfer.

The way in which IFTD manages protocols to transfer data is inspired by the BASE methodology~\cite{base_paper}, is similar in design to the \textit{mux conduits} and \textit{protocol conduits} defined in the Conduits+ framework~\cite{conduits_paper}, and is similar in implementation to the way BitTorrent receives data~\cite{BitTorrent}. Protocol behavior is dictated within IFTD by a high-level construct similar to a mux conduit called a \textit{transfer processor}, which like BitTorrent implements a bitmap to represent which byte-ranges of the data have been transferred and which have not.  Protocol implementations run concurrently and rejuvenate on every transfer to achieve a degree of transfer fault tolerance as recommended by the BASE methodology.  Unlike Conduits+, however, IFTD's transfer processor is designed to manage application-layer protocols instead of transport-layer protocols.  Unlike BitTorrent, IFTD handles scenarios where information that would otherwise be provided in a .torrent file, such as file size and chunk hashes, is not known in advance, and also implements a chunk-handling system that can optionally accommodate more data than expected and make guarantees about the chunk sizes and file reassembly that BitTorrent does not.

Finally, with regards to real-world applicability, IFTD instances are not limited to communicating with other IFTD instances.  Like the abilities of the giFT and Slurpie~\cite{slurpie_paper} multiprotocol implementations, IFTD expects its protocol implementations to be able to communicate with alternative remote services well enough for the remote service to treat IFTD like a typical piece of client software.
