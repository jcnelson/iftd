\section{Introduction}

IFTD is a data transfer service that provides a uniform interface for applications to transfer data via a variety of data transfer protocols \footnote[1]{In this paper, a \textit{data transfer protocol} not only refers to any protocol conventionally used to transmit data between two or more hosts (e.g. HTTP, FTP, BitTorrent, etc.), but also any program or service IFTD can use to send and receive data (e.g. scp, CoDeeN, Gush, etc).  Data transfer protocols exist within IFTD as pairs--a sender and a receiver.}.  An application that uses IFTD provides it with as much information as it has about the desired data (e.g. host, name, size, hash, etc.), as well as any additional information on how IFTD should use each available protocol (e.g. port numbers, login credentials, certificate authorities, etc.).  If the application invokes IFTD to send data, it will additionally provide it with as much information as it has about the data itself.

If the local IFTD instance is able to connect to an IFTD instance on the remote host, both instances examine the data features, select a set of protocols available to both of them, and determine the best protocol for transferring the data.  They then rely on the selected protocol to transfer the data from the source host (the host sending the data) to the destination host (the host receiving the data), but will select different protocols available to both in the event that the chosen protocol fails.  If the local IFTD instance cannot contact a remote IFTD instance, it instead attempts to connect to the remote host with each protocol it supports until one is accepted, and then performs the data transfer via that protocol.

Currently, there are many data transfer protocols an application may use to transfer data, each with its own set of use cases~\cite{application_layer_protocols}.  Depending on the application's data transfer requirements, some protocols are preferable to others in certain cases, depending on the specific nature of the data.  For example, downloading a web page to a single host is generally faster with HTTP than with BitTorrent, whereas downloading a software package to many PlanetLab hosts~\cite{planetlab} from a single repository is generally faster with BitTorrent than HTTP~\cite{stork_paper}, but neither HTTP nor BitTorrent are necessarily faster at sending short messages than IRC.

This variety poses a problem when designing new data transfer applications--the application developer must determine in advance which protocols to use for data transfer, and in which cases each protocol is applicable.  It is intractable from an engineering standpoint to do this for every single data transfer application for several reasons.  First, a change in the behavior of one protocol may require updating the protocol implementations in each application that uses it.  Also, a change in the data requirements of an application could mean re-engineering part of or all of the application's protocol usages.  Additionally, applications using the same protocols may inadvertently interfere with one another's ability to transfer data (e.g. one may require exclusive access to the same range of ports, blocking another's ability to use them).  Finally, it can be difficult to design an application to tolerate protocol errors, depending on how error recovery would need to be implemented each time the protocol is invoked.  These considerations only constrain an application's ability to use the best protocol for each data transfer.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{diagrams/iftd-overview}
    \caption{IFTD Overview}
    \label{iftd-overview}
\end{figure}

The solution to these problems is a data transfer service that intelligently selects the best protocol to transfer data, based on properties of the data itself and protocol usage information from the application.  If sending data, it should make the data available to be pulled by a destination host via as many different protocols as possible along with the best protocol.  If receiving data, it should also be ready to accept data pushed to it via any available protocol in addition to the best protocol.  This removes the burden of designing applications to each use many different protocols; instead, the applications only need to use the data transfer service.  Since the service identifies which protocols are best for transferring different classes of data, and prepares itself to communicate via as many different protocols as possible, the service reduces the application's burden of identifying which protocols should be used in which data transfer scenarios.

This paper presents a prototype implementation of such a data transfer service--the Intelligent File Transfer Daemon (IFTD).  The use of IFTD for data transfers provides several opportunities to improve the quality of transmission that would otherwise be unavailable to individual applications.  Since IFTD makes as many protocols as possible available for each data transfer, the transmission itself tolerates faults in individual protocols during the transfer.  In the event that the transmission is interrupted or fails in one protocol, IFTD can select from its remaining protocols to resume transmission until either the transmission has completed or all protocols have been rendered unusable.

To implement automatic protocol fault tolerance, IFTD may break the data into fixed-length chunks to be sent via its available protocols, making each protocol resumable regardless of whether or not the protocol originally supported it.  This way, in the event that one or more protocols become unavailable during transmission, the destination host does not need to re-transfer data from the source host.

To increase bandwidth while receiving data, the receiving IFTD chooses the fastest protocol for transmission based on prior experience.  It first acquires data features that influence transmission speed from the sending IFTD and optionally from the application.  It then uses these features as input to a discriminatory classifier to identify the fastest protocol most frequently associated with data with similar features.  It informs the sending IFTD of its decision, so the sending IFTD can subsequently use this protocol most frequently to send data.  Once transmission is complete, the receiving IFTD identifies the fastest protocol used in this transfer and refines the classifier data with this protocol and the transfer data's features, this improving its classifier's ability to choose the fastest protocol in subsequent transfers.

The remainder of this paper is organized as follows.  First, it presents a survey of previous work related to the ways in which IFTD solves the aforementioned problems.  Next, it presents a top-down view of the architecture of IFTD as a multiprotocol data transfer service, given the context of the related work.  It then presents an evaluation of IFTD's performance in comparison to two other multi-protocol data transfer frameworks: the file transfer framework arizonatransfer from Stork~\cite{stork_paper}, and the \texttt{urllib2} module in Python 2.5.  Finally, this paper discusses further work in refining the selection of ``good" protocols for transferring data under a variety of circumstances.



