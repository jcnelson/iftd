\section{Discussion}

The experiments presented in this paper are conducted in an idealized environment.  In all cases, there is one source host and one destination host connected on a LAN, there is no other network traffic, the bandwidth is practically free, and the system load on both hosts is minimal.  This allows IFTD to benefit from using additional but less desirable protocols to transfer data while incurring little cost, it allows IFTD to, in some cases, receive more data than necessary, and it mitigates the advantages of identifying the best data transfer protocol.

\subsection{Handling Protocol Behavior}

In real-world uses, there is a cost associated with using an active protocol to send or receive.  Some protocols may require a nontrivial amount of memory or CPU time to run effectively due to features such as internal bufferring, internal integrity checks, encryption, etc.  While IFTD measures protocol bandwidth to decide which protocol is the best protocol for receiving data, it does not consider how using the protocol affects the system's available resources.  This is problematic for applications that already require a large percentage of the system's resources, since using IFTD to handle such an application's transfer needs may accidentally cause the system's resources to become too scarce for the application to run effectively.  While an application may inform IFTD in advance of which protocols are acceptable to use to mitigate this problem, ideally it would only need to inform IFTD of its maximum tolerances for system resource usages and have IFTD only use protocols that keep its resource usage below the maximum.

Another real-world consideration is that the protocol with the highest bandwidth may not be the most desirable protocol for a particular application.  For example, the protocol with the lowest latency may be preferable to protocol with the highest bandwidth in certain cases, and the protocol that can compress data to the smallest possible size may be preferred in other cases.  One future improvement on IFTD is to allow an application to identify a set of features for IFTD to measure in order to cause the classifier to favor protocols based on different criteria than the highest bandwidth.

The fact that IFTD starts passive receivers automatically, regardless of whether or not they have historically been the best protocol with which to receive data, poses a problem for applications in situations where bandwidth is expensive.  The experimental results from Figure~\ref{protocol-effective-bandwidth} indicate that using an NCP concurrently with one or more DCPs can increase the number of duplicate chunk transfers over 50 percent.  However, as seen in Figure~\ref{protocol-fault-toleration}, there are scenarios where an NCP is considered to be the best protocol with which to perform transfers since it has the highest bandwidth.  Also, using a DCP while an NCP is \textit{not} receiving data, like how the HTTP protocol received all 65 of its chunks before the BitTorrent protocol began to receive, could potentially increase IFTD's total bandwidth without using too many system resources.  These observations suggest that the best protocol with which to receive data can change during the course of a data transfer, and that the calculation for the best protocol must consider more information than average bandwidth.

One possible improvement to IFTD's data transfer algorithm is to recalculate $p(X_{now}|b)$ periodically during the data transfer and then calculate the best protocol $b$ given data feature vector $X_{now}$ representing the data transferred thus far.  If $b$ changes, and IFTD is receiving data from a remote IFTD, it would inform the remote IFTD of the change.  However, communicating with the remote IFTD would incur the cost of an XMLRPC round-trip, and it is not immediately clear how representative $X_{now}$ is of the data yet to be transferred.  Also, the relevance of prior completed transfers should be considered, since the current transfer may be unrepresentative of typical data transfers for this classification of data.  The weight of each calculation used to choose protocols that maximize data transfer bandwidth still need to be explored.

Another possible improvement is to make use of the fact that data used by the naive Bayes classifier can be used to calculate $p(b_i|X)$ for any protocol.  As a result, IFTD can calculate the best $k$ protocols to use to transfer data with features $X$, where $k$ can be given by the application.  Doing this means that IFTD does not necessarily need to start all passive receivers; instead it may have at most $k$ receivers running at once regardless of whether or not they are passive or active.  This represents a compromise between running all receivers, which potentially takes up too many system resources, and running only the best receiver, which increases the likelihood that a source host sends the destination host data only to have it rejected since the data cannot be received by the currently running protocol.  The effects that the values for $p(b_i|X)$ for the $k$ best protocols and the effects that the choice for $k$ given $n$ protocols have on the choice of the best protocol are yet to be determined.

\subsection{Choosing the Best Protocol}

There are many alternative methods of calculating the best protocol with which to transfer data given IFTD's architecture.  For example, in order to consider the system-wide effects of using a given protocol, IFTD could record the average $bandwidth / (1 + \Delta{CPU})$ or $bandwidth / (1 + \Delta{Memory})$ or a combination of the two, calculated per transfer, in order favor high-bandwidth protocols that increase IFTD's CPU and memory usage minimally.  Also, IFTD could instead calculate $1 / latency$ for each protocol to favor the protocol with the lowest latency.  Additionally, an application could supply IFTD with weights for each protocol's $p(b_i|X)$ based on application-defined desirable traits, such as the presence of data encryption or the usage of certain port ranges.  This favorability information may be beyond the scope of IFTD to calculate but may affect the usability of the protocols enough that providing it is warranted for a specific transfer.  Future experimentation with IFTD may determine which if any of these alternatives allow IFTD to make better decisions in general.

Since IFTD depends on a naive Bayes classifier for choosing the best protocol, the choices for the features it measures for data transferred were made with the intuition that they have little or no correlation among themselves in general.  If this is true, then the assumption made by the classifier that $x_i$ is independent of $x_j$ when $i \neq j$ is well-founded.  However, a naive Bayes classifier can perform well even when its probability assumptions are incorrect~\cite{naivebayes}.  Consequentially, IFTD may make more accurate choices if it considered some (but not many) additional features.  For example, IFTD could record the set of IP addresses from the remote hosts it engages during data transfer, the port number(s) used during the transfer, and some information about the remote services engaged to perform the transfer (e.g. the version number, software brand name, etc.), since these features may also have an effect on how well the data is transferred.  Further experimentation with real-world data transfers is needed to determine which subset of features are the most useful for choosing the best protocol.
