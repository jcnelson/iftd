Description of Experiments

NOTE: ??? denotes questionable text

TODO: 
--get access to a cluster for testing (Dr. Hartman knows who to contact)
--create three IFTD more HTTP protocols:
    * one that responds immediately but caps bandwidth
    * one that responds after a second and does NOT cap bandwidth
    * one that by default communicates on a non-standard port (i.e. port 81)
--create a client program that can time the use of urllib2, arizonatransfer, and IFTD to use HTTP to get a remote file
--finish the parts of IFTD that will be needed for all of this

=============
Experiment 1:  3-way comparison for transferring a file from one host to another on a LAN.
=============
Purpose:
    To calculate the overhead required by urllib2, arizonatransfer, and IFTD to receive files (via HTTP) of variable sizes from a remote host, assuming unchanging network performance.

Expected result:
    urllib2 will be the fastest, and thus have the least overhead in all cases, followed by arizonatransfer, followed by IFTD.

Setup:
    There are two hosts:  the server and the client.  The server has files of sizes 1KB, 10KB, 100KB, 1MB, 10MB, 100MB, and 1000MB, all filled with random noise, and all allocated in a tmpfs mount.  Also, the server runs the latest stable version of the Apache web server, and listens on port 80 for HTTP requests.  The server does not do anything extraordinary, such as bandwidth-capping; it is effectively a "dumb" HTTP server that will communicate with at most one client and will send data to the client as fast as possible and can serve any of these files.
    The client will have a running IFTD instance, as well as a script that retrieves each file via urllib2, arizonatransfer, and IFTD 5 times.  The script will use the Python time module to record how long each transmission takes (specifically, the time taken by the method call that does the transfer) and will output the timings upon termination.  The script will pre-allocate the space needed by the data to minimize the unrelated Python VM overhead.  The client will also have a tmpfs mount, and the script will receive the files to that tmpfs mount to avoid I/O delays.  Also, the script itself will reside on a tmpfs mount to avoid unnecessary I/O.
    ??? Since arizonatransfer and iftd both support checking the hashes of the files they transfer, and since in practice both make use of this frequently, checking the hash will be considered to be part of the overhead.
    IFTD will have a chunksize of 100KB.

Procedure:
1.  Populate the server with files of size 1KB, 10KB, 100KB, 1MB, 10MB, 100MB, and 1000MB on a tmpfs mount.
2.  Setup and start Apache as a "dumb" HTTP server, listening on port 80
3.  Download the file from the server to the client 5 times using each method and record the transmission time for each.  This is to be done by a script.
4.  Record the data printed by the client program

=============
Experiment 2:  3-way comparison for tolerating an outright protocol failure mid-transfer on a LAN.
=============
Purpose:
    To measure how quickly a (large) file can be transferred to client if the protocol in use encounters an irrecoverable error (i.e. sudden port blockage) roughly half-way into a file transfer.

Expected result:
    urllib2 will time out and fail to fully receive the file from the server.  Arizonatransfer will fall back to its secondary HTTP protocol (which listens on port 81) and re-download the file once its first HTTP protocol fails.  IFTD, since it has no training data, will download data concurrently with both protocols, but will depend only on its second HTTP protocol (listening on port 81) once the first one is blocked.  IFTD will transfer the file the fastest, followed by arizonatransfer.  urllib2 will not finish.

Setup:
    There are two hosts:  the server and the client.  The server has a single file of size 1000MB filled with random noise on a tmpfs mount (to avoid I/O delays).  It will be running the latest stable Apache web server (the same from Experiment 1), but it will be configured to listen on ports 80 and 81 for HTTP GET messages.  It will otherwise be a "dumb" HTTP server in that it will not cap bandwidth and it will connect to at most one client at a time.
    The client will have a running IFTD instance with two HTTP protocols--one that communicates on port 80, and one that communicates on port 81.  It will also have an additional arizonatransfer HTTP protocol module that is no different from its default HTTP protocol module, except that it will communicate on port 81 instead of port 80. Like in Experiment 1, the client will have a tmpfs mount big enough to receive the server's file, and the script to carry out the experiment will reside on the tmpfs mount as well.
    Arizonatransfer will be configured to receive via HTTP on port 80, and to fall back to HTTP on port 81.  IFTD will be configured to select protocols only from HTTP on port 80 and HTTP on port 81.
    IFTD's chunksize will be 100KB.

Procedure:
1.  Calculate the following:
* Let T_u be the average time required to transfer a 1000MB file from server to client using urllib2, as determined in Experiment 1.  
* Let T_a be the average time required to transfer a 1000MB file from server to client using arizontransfer, as determined in Experiment 1.
* Let T_i be the average time required to transfer a 1000MB file from server to client using IFTD, as determined by Experiment 1.
* Let T_start be the time recorded just before invoking the transfer method (calculated by Python's time module)
2.  Download the file to the client via urllib2.  At time T_start + 0.5 * T_u, block port 80 via iptables.  Record the time from T_start to the point where urllib2 fails.  Do this 5 times.
3.  Download the file to the client via arizonatransfer.  At time T_start + 0.5 * T_a, block port 80 via iptables.  Record the time from T_start to the point where arizonatransfer transfers the file completely (once it falls back to its second HTTP protocol on port 81).  Do this 5 times.
4.  Download the file to the client via iftd.  At time T_start + 0.5 * T_i, block port 80 via iptables.  Record the time from T_start to the point where iftd transfers the file completely.  Do this 5 times.
5.  Record the data from steps 3-5.


=============
Experiment 3:  Protocol favoratism based on file size
=============
Purpose:
    To determine how well IFTD learns to favor one protocol over another when file size influences the choice.

Expected Result:
    IFTD will learn to favor an HTTP protocol that responds immediately to HTTP GETs but caps bandwidth for retrieving small files, and will learn to favor an HTTP protocol that responds after a short delay, but does not cap bandwidth for retrieving large files.

Setup:
    Thre are two hosts:  the server and the client.  The server has a set of files of size 1KB, 10KB, 100KB, 1MB, 10MB, 100MB, and 1000MB on a tmpfs mount, as in Experiment 1.  It runs the latest stable Apache server, which can serve any of these files.  It will listen on port 80 for HTTP requests, but will otherwise be a "dumb" server that does nothing extraordinary such as bandwidth-capping; it serves files as fast as possible to at most one client.
    The client will have a running IFTD instance with two HTTP protocols.  The first will retrieve data and give it back to IFTD immediately, but will never allow itself to give back data faster than 100KB/sec.  The second will retrieve data immediately, but will wait for 1 second before giving its first data back to IFTD (after which it will give data to IFTD as fast as it can).  The client will give IFTD a choice between only these two protocols.  IFTD will be configured to retrieve data without the classifier for 45 transfers to get some initial training data, and then train its classifier with the data ad us it for 5 transfers where it chooses the protocol.
    IFTD's chunk size will vary such that it will receive each file in 10 chunks (chunk sizes of 100 bytes, 1KB bytes, 10KB, 100KB, 1MB, 10MB, and 100MB).  It will be configured to, for each transfer, print out how long each chunk took in that transfer and which protocol was used.

Procedure:
1.  Retrieve each file 50 times via IFTD, using one iftjob* instance (just give to IFTD 50 times).  After the 50th transfer, calculate a feature vector with IFTD's stats API from the invariant iftjob and have IFTD print out the posterior probabilities of both protocols given that feature vector (the protocol with the highest probability is given back by the classifier, but we can get the probabilities for each protocol).

*iftjob is a class that describes a transfer.



=============
Experiment 4:  IFTD recoverability and resumability
=============
Purpose:
    To measure how quickly IFTD can resume file transmission in the event of a protocol failure.

Expected Result:
    IFTD will be slower at transferring the file if there are multiple protocol failures, but the file will successfully download without having to completely re-download data, as with arizonatransfer.

Setup:
    There are two hosts:  the server and the client.  The server has a file of size 1MB on a tmpfs mount.  Both the server and the client run IFTD, and both instances support HTTP, scp, BitTorrent, and arizonatransfer_http protocols.  HTTP and BitTorrent support resuming natively, whereas arizonatransfer_http and scp do not.  Each of the protocols have been modified to fail after they give back their 5th received chunk to IFTD.  IFTD will be given fake training data to cause it to favor HTTP, arizonatransfer_http, scp and BitTorrent in that order for the feature vectors it will be supplied in this experiment.
    IFTD will have a chunksize of 50 KB, so it will finish the transfer when the last protocol sends its last chunk.  We expect to see it fail and recover 3 times.  Since IFTD will not be learning in this experiment, it will always try HTTP, then arizonatransfer_http, then scp, and finally BitTorrent.  However, it should successfully retrieve the file.

Procedure:
1.  Train the client IFTD with fake data, causing it to favor HTTP, arizonatransfer_http, scp, and BitTorrent in that order when given feature vectors for this 1MB file.
2.  Have IFTD attempt to download the file 5 times, and record timestamps (with Python's time module) it encounters a failure and reverts to the next-most-favorable protocol.  Also, record the time it took to transfer each chunk, as well as the entire file.  Have IFTD verify the file's integrity.
